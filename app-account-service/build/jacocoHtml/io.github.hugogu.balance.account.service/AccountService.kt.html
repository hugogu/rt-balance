<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccountService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app-account-service</a> &gt; <a href="index.source.html" class="el_package">io.github.hugogu.balance.account.service</a> &gt; <span class="el_source">AccountService.kt</span></div><h1>AccountService.kt</h1><pre class="source lang-java linenums">package io.github.hugogu.balance.account.service

import io.github.hugogu.balance.account.config.RedisConfig.Companion.ACCOUNT_DETAIL_CACHE
import io.github.hugogu.balance.account.config.KafkaConfig
import io.github.hugogu.balance.account.repo.AccountRepo
import io.github.hugogu.balance.account.repo.AccountEntity
import io.github.hugogu.balance.account.repo.ProcessingStatus
import io.github.hugogu.balance.account.repo.TransactionLogEntity
import io.github.hugogu.balance.account.repo.TransactionLogRepo
import io.github.hugogu.balance.common.model.TransactionMessage
import jakarta.persistence.EntityNotFoundException
import jakarta.persistence.LockModeType
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.cache.annotation.CacheEvict
import org.springframework.cache.annotation.Cacheable
import org.springframework.cache.annotation.Caching
import org.springframework.dao.NonTransientDataAccessException
import org.springframework.dao.TransientDataAccessException
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.redis.core.RedisOperations
import org.springframework.data.repository.findByIdOrNull
import org.springframework.kafka.core.KafkaOperations
import org.springframework.retry.annotation.Retryable
import org.springframework.stereotype.Service
import org.springframework.transaction.TransactionException
import org.springframework.transaction.annotation.Isolation
import org.springframework.transaction.annotation.Transactional
import org.springframework.validation.annotation.Validated
import java.math.BigDecimal
import java.time.Duration
import java.util.UUID
import kotlin.ConcurrentModificationException

typealias AccountPair = Pair&lt;AccountEntity, AccountEntity&gt;

@Service
@Validated
<span class="fc" id="L40">class AccountService(</span>
<span class="fc" id="L41">    private val accountRepo: AccountRepo,</span>
<span class="fc" id="L42">    private val transactionLogRepo: TransactionLogRepo,</span>
    redisOperations: RedisOperations&lt;String, String&gt;,
<span class="fc" id="L44">    private val kafkaOperations: KafkaOperations&lt;String, TransactionMessage&gt;,</span>
<span class="fc" id="L45">    @Value(&quot;\${service.lock.timeout}&quot;) private val lockTimeout: Duration</span>
) {
<span class="fc" id="L47">    private val valueOperations = redisOperations.opsForValue()</span>

<span class="fc" id="L49">    @Transactional</span>
    fun createAccount(
        accountNumber: String,
        accountCcy: String,
        balance: BigDecimal,
<span class="fc" id="L54">        requestId: UUID = UUID.randomUUID()</span>
    ): AccountEntity {
<span class="fc" id="L56">        val account = AccountEntity()</span>
<span class="fc" id="L57">        account.setId(requestId)</span>
<span class="fc" id="L58">        account.accountNumber = accountNumber</span>
<span class="fc" id="L59">        account.accountCcy = accountCcy</span>
<span class="fc" id="L60">        account.balance = balance</span>
<span class="fc" id="L61">        return accountRepo.save(account)</span>
    }

    @Cacheable(ACCOUNT_DETAIL_CACHE)
    @Transactional(readOnly = true, isolation = Isolation.READ_COMMITTED)
    fun queryAccountDetail(accountId: UUID): AccountEntity {
<span class="fc" id="L67">        return accountRepo.findById(accountId).orElseThrow {</span>
<span class="fc" id="L68">            EntityNotFoundException(&quot;Can't find account $accountId&quot;)</span>
        }
    }

    /**
     * TODO: The potential issue of partitioning against transactionId is, transactions of the same account scatter.
     *
     * Database level locking is used to ensure the consistency of the account balance.
     */
    @Retryable
    fun postTransactionMessageToBroker(@Valid transaction: TransactionMessage) {
<span class="fc" id="L79">        kafkaOperations.send(KafkaConfig.PENDING_TRANSACTION_TOPIC, transaction.transactionId.toString(), transaction)</span>
<span class="fc" id="L80">            .exceptionally {</span>
<span class="nc" id="L81">                log.error(&quot;Failed to send transaction message to broker&quot;, it)</span>
<span class="nc" id="L82">                null</span>
            }
<span class="fc" id="L84">    }</span>

    fun &lt;T&gt; persistAndProcessTransaction(transaction: TransactionMessage, processor: (TransactionMessage) -&gt; T): T {
<span class="fc" id="L87">        return processWithLock(&quot;transaction-lock:${transaction.transactionId}&quot;) {</span>
            // In synchronous mode, the transaction log is only recorded for reference, not for further processing.
            // So the status upon insertion is just SUCCEED.
<span class="fc" id="L90">            transactionLogRepo.save(TransactionLogEntity.from(transaction, status = ProcessingStatus.SUCCEED))</span>
<span class="fc" id="L91">            processor(transaction)</span>
        }
    }

    @Caching(
        evict = [
            CacheEvict(ACCOUNT_DETAIL_CACHE, key = &quot;{#transaction.fromAccount}&quot;),
            CacheEvict(ACCOUNT_DETAIL_CACHE, key = &quot;{#transaction.toAccount}&quot;)
        ]
    )
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Retryable(include = [TransientDataAccessException::class, TransactionException::class])
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    fun processTransaction(@Valid transaction: TransactionMessage): AccountPair {
<span class="fc" id="L105">        val accounts = accountRepo.findAllById(listOf(transaction.fromAccount, transaction.toAccount))</span>
<span class="pc bpc" id="L106" title="1 of 6 branches missed.">        val from = accounts.find { it.id == transaction.fromAccount }</span>
<span class="fc" id="L107">            ?: throw EntityNotFoundException(&quot;Can't find account ${transaction.fromAccount}&quot;)</span>
<span class="pc bpc" id="L108" title="2 of 6 branches missed.">        val to = accounts.find { it.id == transaction.toAccount }</span>
<span class="nc" id="L109">            ?: throw EntityNotFoundException(&quot;Can't find account ${transaction.toAccount}&quot;)</span>

<span class="fc" id="L111">        from.balance -= transaction.amount</span>
<span class="fc" id="L112">        to.balance += transaction.amount</span>

<span class="fc" id="L114">        return from to to</span>
    }

    @Transactional
    fun persistPendingTransactionMessage(@Valid transaction: TransactionMessage): TransactionLogEntity {
<span class="fc" id="L119">        return transactionLogRepo.save(TransactionLogEntity.from(transaction, status = ProcessingStatus.INIT))</span>
    }

    @Caching(
        evict = [
            CacheEvict(ACCOUNT_DETAIL_CACHE, key = &quot;{#result.fromAccount}&quot;),
            CacheEvict(ACCOUNT_DETAIL_CACHE, key = &quot;{#result.toAccount}&quot;)
        ]
    )
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Retryable(include = [TransientDataAccessException::class, TransactionException::class])
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    fun loadAndProcessLoggedTransaction(transactionId: UUID): TransactionMessage {
<span class="fc" id="L132">        return processWithLock(&quot;transaction-lock:${transactionId}&quot;) {</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">            val transaction = transactionLogRepo.findByIdOrNull(transactionId)</span>
<span class="nc" id="L134">                ?: throw EntityNotFoundException(&quot;Transaction $transactionId not found&quot;)</span>
<span class="fc" id="L135">            try {</span>
<span class="fc" id="L136">                processTransaction(transaction.transactionData)</span>
<span class="fc" id="L137">                transaction.status = ProcessingStatus.SUCCEED</span>
<span class="nc" id="L138">            } catch (ex: NonTransientDataAccessException) {</span>
<span class="nc" id="L139">                log.error(&quot;Failed to process transaction $transactionId&quot;, ex)</span>
<span class="nc" id="L140">                transaction.status = ProcessingStatus.FAILED</span>
            }
<span class="fc" id="L142">            transaction.transactionData</span>
        }
    }

    /**
     * Assume overdraft is allowed. The account balance can be negative.
     *
     * TODO: Support OD limit.
     */
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    fun debitAccount(accountId: UUID, amount: BigDecimal, requestId: UUID): AccountEntity {
<span class="fc" id="L153">        return processWithLock(&quot;request-lock:${requestId}&quot;) {</span>
<span class="fc" id="L154">            val account = accountRepo.findById(accountId).orElseThrow {</span>
<span class="nc" id="L155">                EntityNotFoundException(&quot;Can't find account $accountId&quot;)</span>
            }
<span class="fc" id="L157">            account.balance -= amount</span>
<span class="fc" id="L158">            accountRepo.save(account)</span>
        }
    }

    @Transactional(isolation = Isolation.REPEATABLE_READ)
    fun creditAccount(accountId: UUID, amount: BigDecimal, requestId: UUID): AccountEntity {
<span class="fc" id="L164">        return processWithLock(&quot;request-lock:${requestId}&quot;) {</span>
<span class="fc" id="L165">            val account = accountRepo.findById(accountId).orElseThrow {</span>
<span class="nc" id="L166">                EntityNotFoundException(&quot;Can't find account $accountId&quot;)</span>
            }
<span class="fc" id="L168">            account.balance += amount</span>
<span class="fc" id="L169">            accountRepo.save(account)</span>
        }
    }

    private fun &lt;T&gt; processWithLock(lockKey: String, action: () -&gt; T): T {
<span class="fc" id="L174">        val isLocked = valueOperations.setIfAbsent(lockKey, &quot;locked&quot;, lockTimeout)</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (isLocked == true) {</span>
<span class="fc" id="L176">            try {</span>
<span class="fc" id="L177">                return action()</span>
            } finally {
<span class="fc" id="L179">                valueOperations.getAndDelete(lockKey)</span>
            }
        } else {
<span class="nc" id="L182">            throw ConcurrentModificationException(&quot;LockKey $lockKey is already being processed&quot;)</span>
        }
    }

    companion object {
<span class="fc" id="L187">        private val log = LoggerFactory.getLogger(AccountService::class.java)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>